// Generated by CoffeeScript 2.5.1
(function() {
  /**
   * @fileoverview Disallow undeclared variables in JSX
   * @author Yannick Croissant
   */
  'use strict';
  /**
   * Checks if a node name match the JSX tag convention.
   * @param {String} name - Name of the node to check.
   * @returns {boolean} Whether or not the node name match the JSX tag convention.
   */
  var getFix, isTagName, tagConvention;

  ({
    getAddImportFix: getFix
  } = require('../utils'));

  tagConvention = /^[a-z]|-/;

  isTagName = function(name) {
    return tagConvention.test(name);
  };

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Disallow undeclared variables in JSX',
        category: 'Possible Errors',
        recommended: true
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowGlobals: {
              type: 'boolean'
            }
          },
          // knownImports:
          //   type: 'object'
          // knownImportsFile:
          //   type: 'string'
          additionalProperties: false
        }
      ],
      fixable: 'code'
    },
    create: function(context) {
      /**
       * Compare an identifier with the variables declared in the scope
       * @param {ASTNode} node - Identifier or JSXIdentifier node
       * @returns {void}
       */
      var allImports, allowGlobals, checkIdentifierInJSX, config, lastNonlocalImport;
      config = context.options[0] || {};
      allowGlobals = config.allowGlobals || false;
      checkIdentifierInJSX = function(node) {
        var i, len, name, scope, scopeType, sourceCode, sourceType, variables;
        scope = context.getScope();
        sourceCode = context.getSourceCode();
        ({sourceType} = sourceCode.ast);
        ({variables} = scope);
        // Ignore 'this' keyword (also maked as JSXIdentifier when used in JSX)
        if (node.name === 'this') {
          return;
        }
        scopeType = !allowGlobals && sourceType === 'module' ? 'module' : 'global';
        while (scope.type !== scopeType) {
          scope = scope.upper;
          variables = [...scope.variables, ...variables];
        }
        if (scope.childScopes.length) {
          variables = [...scope.childScopes[0].variables, ...variables];
          if (scope.childScopes[0].childScopes.length) {
            // Temporary fix for babel-eslint
            variables = [...scope.childScopes[0].childScopes[0].variables, ...variables];
          }
        }
        for (i = 0, len = variables.length; i < len; i++) {
          ({name} = variables[i]);
          if (name === node.name) {
            return;
          }
        }
        return context.report({
          node,
          message: `'${node.name}' is not defined.`,
          fix: getFix({
            name: node.name,
            context,
            allImports,
            lastNonlocalImport
          })
        });
      };
      allImports = [];
      lastNonlocalImport = {};
      return {
        ImportDeclaration: function(node) {
          return allImports.push(node);
        },
        JSXOpeningElement: function({name}) {
          var node;
          switch (name.type) {
            case 'JSXIdentifier':
              node = name;
              if (isTagName(node.name)) {
                return;
              }
              break;
            case 'JSXMemberExpression':
              node = name.object;
              while (node && node.type !== 'JSXIdentifier') {
                node = node.object;
              }
              break;
            case 'JSXNamespacedName':
              node = name.namespace;
          }
          return checkIdentifierInJSX(node);
        }
      };
    }
  };

}).call(this);
