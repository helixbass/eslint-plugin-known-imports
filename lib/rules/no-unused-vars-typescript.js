// Generated by CoffeeScript 2.5.1
(function() {
  var AST_NODE_TYPES, PatternVisitor, TSESLint, getRemoveImportFix, util;

  ({AST_NODE_TYPES, TSESLint} = require('@typescript-eslint/experimental-utils'));

  ({PatternVisitor} = require('@typescript-eslint/scope-manager'));

  util = require('@typescript-eslint/eslint-plugin/dist/util');

  ({getRemoveImportFix} = require('../utils'));

  module.exports = util.createRule({
    name: 'no-unused-vars',
    meta: {
      type: 'problem',
      docs: {
        description: 'Disallow unused variables',
        category: 'Variables',
        recommended: 'warn',
        extendsBaseRule: true
      },
      schema: [
        {
          oneOf: [
            {
              enum: ['all',
            'local']
            },
            {
              type: 'object',
              properties: {
                vars: {
                  enum: ['all',
            'local']
                },
                varsIgnorePattern: {
                  type: 'string'
                },
                args: {
                  enum: ['all',
            'after-used',
            'none']
                },
                ignoreRestSiblings: {
                  type: 'boolean'
                },
                argsIgnorePattern: {
                  type: 'string'
                },
                caughtErrors: {
                  enum: ['all',
            'none']
                },
                caughtErrorsIgnorePattern: {
                  type: 'string'
                },
                onlyRemoveKnownImports: {
                  type: 'boolean'
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}."
      },
      fixable: 'code'
    },
    defaultOptions: [{}],
    create: function(context) {
      var MODULE_DECL_CACHE, ambientDeclarationSelector, checkModuleDeclForExportEquals, collectUnusedVariables, filename, markDeclarationChildAsUsed, options, sourceCode, visitPattern;
      filename = context.getFilename();
      sourceCode = context.getSourceCode();
      MODULE_DECL_CACHE = new Map();
      checkModuleDeclForExportEquals = function(node) {
        var cached, ref1, ref2, ref3, statement;
        cached = MODULE_DECL_CACHE.get(node);
        if (cached != null) {
          return cached;
        }
        ref3 = (ref1 = (ref2 = node.body) != null ? ref2.body : void 0) != null ? ref1 : [];
        for (statement of ref3) {
          if (statement.type === AST_NODE_TYPES.TSExportAssignment) {
            MODULE_DECL_CACHE.set(node, true);
            return true;
          }
        }
        MODULE_DECL_CACHE.set(node, false);
        return false;
      };
      markDeclarationChildAsUsed = function(node) {
        var declaration, id, identifiers, ref1, ref2, results, scope, shouldUseUpperScope, superVar;
        identifiers = [];
        switch (node.type) {
          case AST_NODE_TYPES.TSInterfaceDeclaration:
          case AST_NODE_TYPES.TSTypeAliasDeclaration:
          case AST_NODE_TYPES.ClassDeclaration:
          case AST_NODE_TYPES.FunctionDeclaration:
          case AST_NODE_TYPES.TSDeclareFunction:
          case AST_NODE_TYPES.TSEnumDeclaration:
          case AST_NODE_TYPES.TSModuleDeclaration:
            if (((ref1 = node.id) != null ? ref1.type : void 0) === AST_NODE_TYPES.Identifier) {
              identifiers.push(node.id);
            }
            break;
          case AST_NODE_TYPES.VariableDeclaration:
            ref2 = node.declarations;
            for (declaration of ref2) {
              visitPattern(declaration, function(pattern) {
                identifiers.push(pattern);
                return void 0;
              });
            }
        }
        scope = context.getScope();
        shouldUseUpperScope = [AST_NODE_TYPES.TSModuleDeclaration, AST_NODE_TYPES.TSDeclareFunction].includes(node.type);
        if (scope.variableScope !== scope) {
          scope = scope.variableScope;
        } else if (shouldUseUpperScope && scope.upper) {
          scope = scope.upper;
        }
        results = [];
        for (id of identifiers) {
          superVar = scope.set.get(id.name);
          if (superVar) {
            results.push(superVar.eslintUsed = true);
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      visitPattern = function(node, cb) {
        var visitor;
        visitor = new PatternVisitor({}, node, cb);
        return visitor.visit(node);
      };
      options = (function() {
        var _options, firstOption, ref1, ref2, ref3, ref4, ref5;
        _options = {
          vars: 'all',
          args: 'after-used',
          ignoreRestSiblings: false,
          caughtErrors: 'none',
          onlyRemoveKnownImports: false
        };
        firstOption = context.options[0];
        if (firstOption) {
          if (typeof firstOption === 'string') {
            _options.vars = firstOption;
          } else {
            _options.vars = (ref1 = firstOption.vars) != null ? ref1 : _options.vars;
            _options.args = (ref2 = firstOption.args) != null ? ref2 : _options.args;
            _options.ignoreRestSiblings = (ref3 = firstOption.ignoreRestSiblings) != null ? ref3 : _options.ignoreRestSiblings;
            _options.caughtErrors = (ref4 = firstOption.caughtErrors) != null ? ref4 : _options.caughtErrors;
            _options.onlyRemoveKnownImports = (ref5 = firstOption.onlyRemoveKnownImports) != null ? ref5 : _options.onlyRemoveKnownImports;
            if (firstOption.varsIgnorePattern) {
              _options.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, 'u');
            }
            if (firstOption.argsIgnorePattern) {
              _options.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, 'u');
            }
            if (firstOption.caughtErrorsIgnorePattern) {
              _options.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, 'u');
            }
          }
        }
        return _options;
      })();
      collectUnusedVariables = function() {
        /**
         * Determines if a variable has a sibling rest property
         * @param variable eslint-scope variable object.
         * @returns True if the variable is exported, false if not.
         */
        /**
         * Checks whether the given variable is after the last used parameter.
         * @param variable The variable to check.
         * @returns `true` if the variable is defined after the last used parameter.
         */
        var def, hasRestSpreadSibling, isAfterLastUsedArg, ref1, ref2, ref3, unusedVariablesOriginal, unusedVariablesReturn, variable;
        hasRestSpreadSibling = function(variable) {
          if (options.ignoreRestSiblings) {
            return variable.defs.some(function(def) {
              var patternNode, propertyNode;
              propertyNode = def.name.parent;
              patternNode = propertyNode.parent;
              return propertyNode.type === AST_NODE_TYPES.Property && patternNode.type === AST_NODE_TYPES.ObjectPattern && patternNode.properties[patternNode.properties.length - 1].type === AST_NODE_TYPES.RestElement;
            });
          }
          return false;
        };
        isAfterLastUsedArg = function(variable) {
          var def, params, posteriorParams;
          def = variable.defs[0];
          params = context.getDeclaredVariables(def.node);
          posteriorParams = params.slice(params.indexOf(variable) + 1);
          // If any used parameters occur after this parameter, do not report.
          return !posteriorParams.some(function(v) {
            return v.references.length > 0 || v.eslintUsed;
          });
        };
        unusedVariablesOriginal = util.collectUnusedVariables(context);
        unusedVariablesReturn = [];
        for (variable of unusedVariablesOriginal) {
          // explicit global variables don't have definitions.
          if (variable.defs.length === 0) {
            unusedVariablesReturn.push(variable);
            continue;
          }
          def = variable.defs[0];
          if (variable.scope.type === TSESLint.Scope.ScopeType.global && options.vars === 'local') {
            // skip variables in the global scope if configured to
            continue;
          }
          // skip catch variables
          if (def.type === TSESLint.Scope.DefinitionType.CatchClause) {
            if (options.caughtErrors === 'none') {
              continue;
            }
            if ('name' in def.name && ((ref1 = options.caughtErrorsIgnorePattern) != null ? ref1.test(def.name.name) : void 0)) {
              // skip ignored parameters
              continue;
            }
          }
          if (def.type === TSESLint.Scope.DefinitionType.Parameter) {
            if (options.args === 'none') {
              // if "args" option is "none", skip any parameter
              continue;
            }
            if ('name' in def.name && ((ref2 = options.argsIgnorePattern) != null ? ref2.test(def.name.name) : void 0)) {
              // skip ignored parameters
              continue;
            }
            if (options.args === 'after-used' && util.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
              // if "args" option is "after-used", skip used variables
              continue;
            }
          } else {
            if ('name' in def.name && ((ref3 = options.varsIgnorePattern) != null ? ref3.test(def.name.name) : void 0)) {
              // skip ignored variables
              continue;
            }
          }
          if (hasRestSpreadSibling(variable)) {
            continue;
          }
          if (variable.eslintUsed) {
            // in case another rule has run and used the collectUnusedVariables,
            // we want to ensure our selectors that marked variables as used are respected
            continue;
          }
          unusedVariablesReturn.push(variable);
        }
        return unusedVariablesReturn;
      };
      ambientDeclarationSelector = function(parent, childDeclare) {
        return [
          // Types are ambiently exported
          `${parent} > :matches(${[AST_NODE_TYPES.TSInterfaceDeclaration,
          AST_NODE_TYPES.TSTypeAliasDeclaration].join(', ')})`,
          // Value things are ambiently exported if they are "declare"d
          `${parent} > :matches(${[AST_NODE_TYPES.ClassDeclaration,
          AST_NODE_TYPES.TSDeclareFunction,
          AST_NODE_TYPES.TSEnumDeclaration,
          AST_NODE_TYPES.TSModuleDeclaration,
          AST_NODE_TYPES.VariableDeclaration].join(', ')})${childDeclare ? '[declare = true]' : ''}`
        ].join(', ');
      };
      return {
        // declaration file handling
        [ambientDeclarationSelector(AST_NODE_TYPES.Program, true)]: function(node) {
          if (!util.isDefinitionFile(filename)) {
            return;
          }
          markDeclarationChildAsUsed(node);
          return void 0;
        },
        // children of a namespace that is a child of a declared namespace are auto-exported
        [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock TSModuleDeclaration > TSModuleBlock', false)]: function(node) {
          markDeclarationChildAsUsed(node);
          return void 0;
        },
        // declared namespace handling
        [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock', false)]: function(node) {
          var moduleDecl, ref1;
          // declared ambient modules with an `export =` statement will only export that one thing
          // all other statements are not automatically exported in this case
          moduleDecl = util.nullThrows((ref1 = node.parent) != null ? ref1.parent : void 0, util.NullThrowsReasons.MissingParent);
          if (moduleDecl.id.type === AST_NODE_TYPES.Literal && checkModuleDeclForExportEquals(moduleDecl)) {
            return;
          }
          markDeclarationChildAsUsed(node);
          return void 0;
        },
        // collect
        'Program:exit': function(programNode) {
          /**
           * Generate the warning message about the variable being
           * assigned and unused, including the ignore pattern if configured.
           * @param unusedVar eslint-scope variable object.
           * @returns The message data to be used with this unused variable.
           */
          var directiveComment, getAssignedMessageData, getDefinedMessageData, i, len, unusedVar, unusedVars;
          getDefinedMessageData = function(unusedVar) {
            var additional, defType, pattern, ref1, type;
            defType = unusedVar != null ? (ref1 = unusedVar.defs[0]) != null ? ref1.type : void 0 : void 0;
            if (defType === TSESLint.Scope.DefinitionType.CatchClause && options.caughtErrorsIgnorePattern) {
              type = 'args';
              pattern = options.caughtErrorsIgnorePattern.toString();
            } else if (defType === TSESLint.Scope.DefinitionType.Parameter && options.argsIgnorePattern) {
              type = 'args';
              pattern = options.argsIgnorePattern.toString();
            } else if (defType !== TSESLint.Scope.DefinitionType.Parameter && options.varsIgnorePattern) {
              type = 'vars';
              pattern = options.varsIgnorePattern.toString();
            }
            additional = type ? `. Allowed unused ${type} must match ${pattern}` : '';
            return {
              varName: unusedVar.name,
              action: 'defined',
              additional
            };
          };
          getAssignedMessageData = function(unusedVar) {
            var additional;
            additional = options.varsIgnorePattern ? `. Allowed unused vars must match ${options.varsIgnorePattern.toString()}` : '';
            return {
              varName: unusedVar.name,
              action: 'assigned a value',
              additional
            };
          };
          unusedVars = collectUnusedVariables();
          for (i = 0, len = unusedVars.length; i < len; i++) {
            unusedVar = unusedVars[i];
            // Report the first declaration.
            if (unusedVar.defs.length > 0) {
              context.report({
                node: unusedVar.references.length ? unusedVar.references[unusedVar.references.length - 1].identifier : unusedVar.identifiers[0],
                messageId: 'unusedVar',
                data: (unusedVar.references.some(function(ref) {
                  return ref.isWrite();
                })) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar),
                fix: getRemoveImportFix({
                  unusedVar,
                  context,
                  onlyRemoveKnownImports: options.onlyRemoveKnownImports
                })
              });
            // If there are no regular declaration, report the first `/*globals*/` comment directive.
            } else if ('eslintExplicitGlobalComments' in unusedVar && unusedVar.eslintExplicitGlobalComments) {
              directiveComment = unusedVar.eslintExplicitGlobalComments[0];
              context.report({
                node: programNode,
                loc: util.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),
                messageId: 'unusedVar',
                data: getDefinedMessageData(unusedVar)
              });
            }
          }
          return void 0;
        }
      };
    }
  });

  /*

Edge cases that aren't currently handled due to laziness and them being super edgy edge cases

--- function params referenced in typeof type refs in the function declaration ---
--- NOTE - TS gets these cases wrong

function _foo(
  arg: number // arg should be unused
): typeof arg {
  return 1 as any;
}

function _bar(
  arg: number, // arg should be unused
  _arg2: typeof arg,
) {}

--- function names referenced in typeof type refs in the function declaration ---
--- NOTE - TS gets these cases right

function foo( // foo should be unused
): typeof foo {
    return 1 as any;
}

function bar( // bar should be unused
  _arg: typeof bar
) {}

--- if an interface is merged into a namespace  ---
--- NOTE - TS gets these cases wrong

namespace Test {
    interface Foo { // Foo should be unused here
        a: string;
    }
    export namespace Foo {
       export type T = 'b';
    }
}
type T = Test.Foo; // Error: Namespace 'Test' has no exported member 'Foo'.

namespace Test {
    export interface Foo {
        a: string;
    }
    namespace Foo { // Foo should be unused here
       export type T = 'b';
    }
}
type T = Test.Foo.T; // Error: Namespace 'Test' has no exported member 'Foo'.
*/
/*

We currently extend base `no-unused-vars` implementation because it's easier and lighter-weight.

Because of this, there are a few false-negatives which won't get caught.
We could fix these if we fork the base rule; but that's a lot of code (~650 lines) to add in.
I didn't want to do that just yet without some real-world issues, considering these are pretty rare edge-cases.

These cases are mishandled because the base rule assumes that each variable has one def, but type-value shadowing
creates a variable with two defs

--- type-only or value-only references to type/value shadowed variables ---
--- NOTE - TS gets these cases wrong

type T = 1;
const T = 2; // this T should be unused

type U = T; // this U should be unused
const U = 3;

const _V = U;

--- partially exported type/value shadowed variables ---
--- NOTE - TS gets these cases wrong

export interface Foo {}
const Foo = 1; // this Foo should be unused

interface Bar {} // this Bar should be unused
export const Bar = 1;
*/

}).call(this);
