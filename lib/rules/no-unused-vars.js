// Generated by CoffeeScript 2.5.1
(function() {
  /**
   * @fileoverview Rule to flag declared but unused variables
   * @author Ilya Volodin
   */
  'use strict';
  var astUtils, knownImportExists, lodash;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  lodash = require('lodash');

  astUtils = require('../eslint-ast-utils');

  ({knownImportExists} = require('../utils'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow unused variables',
        category: 'Variables',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-unused-vars'
      },
      schema: [
        {
          oneOf: [
            {
              enum: ['all',
            'local']
            },
            {
              type: 'object',
              properties: {
                vars: {
                  enum: ['all',
            'local']
                },
                varsIgnorePattern: {
                  type: 'string'
                },
                args: {
                  enum: ['all',
            'after-used',
            'none']
                },
                ignoreRestSiblings: {
                  type: 'boolean'
                },
                argsIgnorePattern: {
                  type: 'string'
                },
                caughtErrors: {
                  enum: ['all',
            'none']
                },
                caughtErrorsIgnorePattern: {
                  type: 'string'
                },
                onlyRemoveKnownImports: {
                  type: 'boolean'
                }
              }
            }
          ]
        }
      ],
      // knownImports:
      //   type: 'object'
      // knownImportsFile:
      //   type: 'string'
      fixable: 'code'
    },
    create: function(context) {
      /**
       * Gets an array of variables without read references.
       * @param {Scope} scope - an eslint-scope Scope object.
       * @param {Variable[]} unusedVars - an array that saving result.
       * @returns {Variable[]} unused variables of the scope and descendant scopes.
       * @private
       */
      /**
       * Generate the warning message about the variable being
       * assigned and unused, including the ignore pattern if configured.
       * @returns {string} The warning message to be used with this unused variable.
       */
      /**
       * Gets the index of a given variable name in a given comment.
       * @param {eslint-scope.Variable} variable - A variable to get.
       * @param {ASTNode} comment - A comment node which includes the variable name.
       * @returns {number} The index of the variable name's location.
       * @private
       */
      /**
       * Generate the warning message about the variable being
       * defined and unused, including the ignore pattern if configured.
       * @param {Variable} unusedVar - eslint-scope variable object.
       * @returns {string} The warning message to be used with this unused variable.
       */
      /**
       * Creates the correct location of a given variables.
       * The location is at its name string in a `/*global` comment.
       *
       * @param {eslint-scope.Variable} variable - A variable to get its location.
       * @returns {{line: number, column: number}} The location object for the variable.
       * @private
       */
      /**
       * If a given reference is left-hand side of an assignment, this gets
       * the right-hand side node of the assignment.
       *
       * In the following cases, this returns null.
       *
       * - The reference is not the LHS of an assignment expression.
       * - The reference is inside of a loop.
       * - The reference is inside of a function scope which is different from
       *   the declaration.
       *
       * @param {eslint-scope.Reference} ref - A reference to check.
       * @param {ASTNode} prevRhsNode - The previous RHS node.
       * @returns {ASTNode|null} The RHS node or null.
       * @private
       */
      /**
       * Determines if a variable has a sibling rest property
       * @param {Variable} variable - eslint-scope variable object.
       * @returns {boolean} True if the variable is exported, false if not.
       * @private
       */
      /**
       * Checks whether the given variable is after the last used parameter.
       *
       * @param {eslint-scope.Variable} variable - The variable to check.
       * @returns {boolean} `true` if the variable is defined after the last
       * used parameter.
       */
      /**
       * Determines if a given variable is being exported from a module.
       * @param {Variable} variable - eslint-scope variable object.
       * @returns {boolean} True if the variable is exported, false if not.
       * @private
       */
      /**
       * Determine if an identifier is used either in for-in loops.
       *
       * @param {Reference} ref - The reference to check.
       * @returns {boolean} whether reference is used in the for-in loops
       * @private
       */
      /**
       * Checks the position of given nodes.
       *
       * @param {ASTNode} inner - A node which is expected as inside.
       * @param {ASTNode} outer - A node which is expected as outside.
       * @returns {boolean} `true` if the `inner` node exists in the `outer` node.
       * @private
       */
      /**
       * Checks whether a given Identifier node exists inside of a function node which can be used later.
       *
       * "can be used later" means:
       * - the function is assigned to a variable.
       * - the function is bound to a property and the object can be used later.
       * - the function is bound as an argument of a function call.
       *
       * If a reference exists in a function which can be used later, the reference is read when the function is called.
       *
       * @param {ASTNode} id - An Identifier node to check.
       * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
       * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.
       * @private
       */
      /**
       * Checks whether a given reference is a read to update itself or not.
       *
       * @param {eslint-scope.Reference} ref - A reference to check.
       * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
       * @returns {boolean} The reference is a read to update itself.
       * @private
       */
      /**
       * Determines if a reference is a read operation.
       * @param {Reference} ref - An eslint-scope Reference
       * @returns {boolean} whether the given reference represents a read operation
       * @private
       */
      /**
       * Determine if an identifier is referencing an enclosing function name.
       * @param {Reference} ref - The reference to check.
       * @param {ASTNode[]} nodes - The candidate function nodes.
       * @returns {boolean} True if it's a self-reference, false if not.
       * @private
       */
      /**
       * Checks whether a given function node is stored to somewhere or not.
       * If the function node is stored, the function can be used later.
       *
       * @param {ASTNode} funcNode - A function node to check.
       * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
       * @returns {boolean} `true` if under the following conditions:
       *      - the funcNode is assigned to a variable.
       *      - the funcNode is bound as an argument of a function call.
       *      - the function is bound to a property and the object satisfies above conditions.
       * @private
       */
      /**
       * Determines if the variable is used.
       * @param {Variable} variable - The variable to check.
       * @returns {boolean} True if the variable is used
       * @private
       */
      var REST_PROPERTY_TYPE, STATEMENT_TYPE, collectUnusedVariables, config, firstOption, getAssignedMessage, getColumnInComment, getDefinedMessage, getFix, getLocation, getRhsNode, hasRestSpreadSibling, isAfterLastUsedArg, isExported, isForInRef, isInside, isInsideOfStorableFunction, isReadForItself, isReadRef, isSelfReference, isStorableFunction, isUsedVariable, sourceCode;
      sourceCode = context.getSourceCode();
      REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/;
      config = {
        vars: 'all',
        args: 'after-used',
        ignoreRestSiblings: false,
        caughtErrors: 'none',
        onlyRemoveKnownImports: false
      };
      firstOption = context.options[0];
      if (firstOption) {
        if (typeof firstOption === 'string') {
          config.vars = firstOption;
        } else {
          config.vars = firstOption.vars || config.vars;
          config.args = firstOption.args || config.args;
          config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
          config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;
          config.onlyRemoveKnownImports = firstOption.onlyRemoveKnownImports || config.onlyRemoveKnownImports;
          // config.knownImports = firstOption.knownImports
          // config.knownImportsFile = firstOption.knownImportsFile
          if (firstOption.varsIgnorePattern) {
            config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
          }
          if (firstOption.argsIgnorePattern) {
            config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
          }
          if (firstOption.caughtErrorsIgnorePattern) {
            config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);
          }
        }
      }
      getDefinedMessage = function(unusedVar) {
        var additional, defType, pattern, ref1, type;
        defType = ((ref1 = unusedVar.defs) != null ? ref1[0] : void 0) && unusedVar.defs[0].type;
        if (defType === 'CatchClause' && config.caughtErrorsIgnorePattern) {
          type = 'args';
          pattern = config.caughtErrorsIgnorePattern.toString();
        } else if (defType === 'Parameter' && config.argsIgnorePattern) {
          type = 'args';
          pattern = config.argsIgnorePattern.toString();
        } else if (defType !== 'Parameter' && config.varsIgnorePattern) {
          type = 'vars';
          pattern = config.varsIgnorePattern.toString();
        }
        additional = type ? ` Allowed unused ${type} must match ${pattern}.` : '';
        return `'{{name}}' is defined but never used.${additional}`;
      };
      getAssignedMessage = function() {
        var additional;
        additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : '';
        return `'{{name}}' is assigned a value but never used.${additional}`;
      };
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      STATEMENT_TYPE = /(?:Statement|Declaration)$/;
      isExported = function(variable) {
        var definition, node;
        definition = variable.defs[0];
        if (definition) {
          ({node} = definition);
          if (node.type === 'VariableDeclarator') {
            node = node.parent;
          } else {
            if (definition.type === 'Parameter') {
              return false;
            }
          }
          return node.parent.type.indexOf('Export') === 0;
        }
        return false;
      };
      hasRestSpreadSibling = function(variable) {
        if (!config.ignoreRestSiblings) {
          return false;
        }
        return variable.defs.some(function(def) {
          var patternNode, propertyNode;
          propertyNode = def.name.parent;
          patternNode = propertyNode.parent;
          return propertyNode.type === 'Property' && patternNode.type === 'ObjectPattern' && REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type);
        });
      };
      isReadRef = function(ref) {
        return ref.isRead();
      };
      isSelfReference = function(ref, nodes) {
        var scope;
        scope = ref.from;
        while (scope) {
          if (nodes.indexOf(scope.block) >= 0) {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      };
      isInside = function(inner, outer) {
        return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
      };
      getRhsNode = function(ref, prevRhsNode) {
        var canBeUsedLater, granpa, id, parent, refScope, varScope;
        id = ref.identifier;
        ({parent} = id);
        granpa = parent.parent;
        refScope = ref.from.variableScope;
        varScope = ref.resolved.scope.variableScope;
        canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);
        if (prevRhsNode && isInside(id, prevRhsNode)) {
          /*
           * Inherits the previous node if this reference is in the node.
           * This is for `a = a + a`-like code.
           */
          return prevRhsNode;
        }
        if (parent.type === 'AssignmentExpression' && granpa.type === 'ExpressionStatement' && id === parent.left && !canBeUsedLater) {
          return parent.right;
        }
        return null;
      };
      isStorableFunction = function(funcNode, rhsNode) {
        var node, parent;
        node = funcNode;
        ({parent} = funcNode);
        while (parent && isInside(parent, rhsNode)) {
          switch (parent.type) {
            case 'SequenceExpression':
              if (!(parent.expressions[parent.expressions.length - 1] === node)) {
                return false;
              }
              break;
            case 'CallExpression':
            case 'NewExpression':
              return parent.callee !== node;
            case 'AssignmentExpression':
            case 'TaggedTemplateExpression':
            case 'YieldExpression':
              return true;
            default:
              if (STATEMENT_TYPE.test(parent.type)) {
                /*
                 * If it encountered statements, this is a complex pattern.
                 * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.
                 */
                return true;
              }
          }
          node = parent;
          ({parent} = parent);
        }
        return false;
      };
      isInsideOfStorableFunction = function(id, rhsNode) {
        var funcNode;
        funcNode = astUtils.getUpperFunction(id);
        return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
      };
      isReadForItself = function(ref, rhsNode) {
        var granpa, id, parent;
        id = ref.identifier;
        ({parent} = id);
        granpa = parent.parent;
        // self update. e.g. `a += 1`, `a++`
        // in RHS of an assignment for itself. e.g. `a = a + 1`
        return ref.isRead() && ((parent.type === 'AssignmentExpression' && granpa.type === 'ExpressionStatement' && parent.left === id) || (parent.type === 'UpdateExpression' && granpa.type === 'ExpressionStatement') || (rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode)));
      };
      isForInRef = function(ref) {
        var target;
        target = ref.identifier.parent;
        // "for (var ...) { return; }"
        if (target.type === 'VariableDeclarator') {
          target = target.parent.parent;
        }
        if (target.type !== 'ForInStatement') {
          return false;
        }
        // "for (...) { return; }"
        if (target.body.type === 'BlockStatement') {
          target = target.body.body[0];
        } else {
          // "for (...) return;"
          target = target.body;
        }
        if (!target) {
          // For empty loop body
          return false;
        }
        return target.type === 'ReturnStatement';
      };
      isUsedVariable = function(variable) {
        var functionNodes, isFunctionDefinition, rhsNode;
        functionNodes = variable.defs.filter(function({type}) {
          return type === 'FunctionName';
        }).map(function({node}) {
          return node;
        });
        isFunctionDefinition = functionNodes.length > 0;
        rhsNode = null;
        return variable.references.some(function(ref) {
          var forItself;
          if (isForInRef(ref)) {
            return true;
          }
          forItself = isReadForItself(ref, rhsNode);
          rhsNode = getRhsNode(ref, rhsNode);
          return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
        });
      };
      isAfterLastUsedArg = function(variable) {
        var def, params, posteriorParams;
        def = variable.defs[0];
        params = context.getDeclaredVariables(def.node);
        posteriorParams = params.slice(params.indexOf(variable) + 1);
        // If any used parameters occur after this parameter, do not report.
        return !posteriorParams.some(function(v) {
          return v.references.length > 0;
        });
      };
      collectUnusedVariables = function(scope, unusedVars) {
        var childScope, childScopes, def, i, j, len, len1, ref1, ref2, ref3, ref4, type, variable, variables;
        ({variables, childScopes} = scope);
        if (scope.type !== 'TDZ' && (scope.type !== 'global' || config.vars === 'all')) {
// skip a variable of class itself name in the class scope

          // skip function expression names and variables marked with markVariableAsUsed()

          // skip implicit "arguments" variable

          // explicit global variables don't have definitions.

          // skip catch variables

          // skip ignored parameters
// skip any setter argument

          // if "args" option is "none", skip any parameter

          // skip ignored parameters

          // if "args" option is "after-used", skip used variables
// skip ignored variables
          for (i = 0, len = variables.length; i < len; i++) {
            variable = variables[i];
            if (scope.type === 'class' && scope.block.id === variable.identifiers[0]) {
              continue;
            }
            if (scope.functionExpressionScope || variable.eslintUsed) {
              continue;
            }
            if (scope.type === 'function' && variable.name === 'arguments' && variable.identifiers.length === 0) {
              continue;
            }
            def = variable.defs[0];
            if (def) {
              ({type} = def);
              if (type === 'CatchClause') {
                if (config.caughtErrors === 'none') {
                  continue;
                }
                if ((ref1 = config.caughtErrorsIgnorePattern) != null ? ref1.test(def.name.name) : void 0) {
                  continue;
                }
              }
              if (type === 'Parameter') {
                if (((ref2 = def.node.parent.type) === 'Property' || ref2 === 'MethodDefinition') && def.node.parent.kind === 'set') {
                  continue;
                }
                if (config.args === 'none') {
                  continue;
                }
                if ((ref3 = config.argsIgnorePattern) != null ? ref3.test(def.name.name) : void 0) {
                  continue;
                }
                if (config.args === 'after-used' && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
                  continue;
                }
              } else if ((ref4 = config.varsIgnorePattern) != null ? ref4.test(def.name.name) : void 0) {
                continue;
              }
            }
            if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
              unusedVars.push(variable);
            }
          }
        }
        for (j = 0, len1 = childScopes.length; j < len1; j++) {
          childScope = childScopes[j];
          collectUnusedVariables(childScope, unusedVars);
        }
        return unusedVars;
      };
      getColumnInComment = function(variable, comment) {
        var match, namePattern;
        namePattern = new RegExp(`[\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\s,:])`, 'g');
        // To ignore the first text "global".
        namePattern.lastIndex = comment.value.indexOf('global') + 6;
        // Search a given variable name.
        match = namePattern.exec(comment.value);
        if (match) {
          return match.index + 1;
        } else {
          return 0;
        }
      };
      getLocation = function(variable) {
        var comment;
        comment = variable.eslintExplicitGlobalComment;
        return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));
      };
      getFix = function({unusedVar}) {
        var def, importDeclaration, importSpecifier;
        def = unusedVar.defs[0];
        if (def.type !== 'ImportBinding') {
          return null;
        }
        if (config.onlyRemoveKnownImports && !knownImportExists({
          name: unusedVar.name,
          context
        })) {
          return null;
        }
        importDeclaration = def.parent;
        importSpecifier = def.node;
        return function(fixer) {
          var isOnlyNamedImport, nextToken, precedingToken, removeBracesAndPrecedingComma, removeEntireImport, removeThroughFollowingComma, removeThroughPrecedingComma;
          removeEntireImport = function() {
            var importIsAtBeginningOfFile, nextToken, nextTokenIsPrecededByBlankLine, precedingComments;
            nextToken = sourceCode.getTokenAfter(importDeclaration);
            if ((precedingComments = sourceCode.getCommentsBefore(nextToken)).length) {
              nextToken = precedingComments[0];
            }
            nextTokenIsPrecededByBlankLine = sourceCode.text.slice((nextToken.range[0] - 2), nextToken.range[0]) === '\n\n';
            importIsAtBeginningOfFile = !sourceCode.getTokenBefore(importDeclaration);
            return fixer.removeRange([importDeclaration.range[0], nextTokenIsPrecededByBlankLine && !importIsAtBeginningOfFile ? nextToken.range[0] - 1 : nextToken.range[0]]);
          };
          removeThroughFollowingComma = function({commaToken}) {
            var followingToken;
            followingToken = sourceCode.getTokenAfter(commaToken);
            return fixer.removeRange([importSpecifier.range[0], followingToken.range[0]]);
          };
          removeThroughPrecedingComma = function({commaToken}) {
            var beforeToken;
            beforeToken = sourceCode.getTokenBefore(commaToken);
            return fixer.removeRange([beforeToken.range[1], importSpecifier.range[1]]);
          };
          removeBracesAndPrecedingComma = function() {
            var beforeToken, closingBrace, openingBrace, precedingComma;
            openingBrace = sourceCode.getTokenBefore(importSpecifier, {
              filter: function({value}) {
                return value === '{';
              }
            });
            closingBrace = sourceCode.getTokenAfter(importSpecifier, {
              filter: function({value}) {
                return value === '}';
              }
            });
            precedingComma = sourceCode.getTokenBefore(openingBrace);
            // assert(precedingComma.value === ',')
            beforeToken = sourceCode.getTokenBefore(precedingComma);
            return fixer.removeRange([beforeToken.range[1], closingBrace.range[1]]);
          };
          if (importDeclaration.specifiers.length === 1) {
            // followingComma = sourceCode.getTokenAfter(closingBrace)
            return removeEntireImport();
          }
          nextToken = sourceCode.getTokenAfter(importSpecifier);
          if (nextToken.value === ',') {
            return removeThroughFollowingComma({
              commaToken: nextToken
            });
          }
          precedingToken = sourceCode.getTokenBefore(importSpecifier);
          if (precedingToken.value === ',') {
            return removeThroughPrecedingComma({
              commaToken: precedingToken
            });
          }
          isOnlyNamedImport = importSpecifier.type === 'ImportSpecifier' && importDeclaration.specifiers.filter(function({type}) {
            return type === 'ImportSpecifier';
          }).length === 1;
          if (isOnlyNamedImport) {
            return removeBracesAndPrecedingComma();
          }
          return fixer.remove(importSpecifier);
        };
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        'Program:exit': function(programNode) {
          var i, len, results, unusedVar, unusedVars;
          unusedVars = collectUnusedVariables(context.getScope(), []);
          results = [];
          for (i = 0, len = unusedVars.length; i < len; i++) {
            unusedVar = unusedVars[i];
            if (unusedVar.eslintExplicitGlobal) {
              results.push(context.report({
                node: programNode,
                loc: getLocation(unusedVar),
                message: getDefinedMessage(unusedVar),
                data: unusedVar
              }));
            } else if (unusedVar.defs.length > 0) {
              results.push(context.report({
                node: unusedVar.identifiers[0],
                message: unusedVar.references.some(function(ref) {
                  return ref.isWrite();
                }) ? getAssignedMessage() : getDefinedMessage(unusedVar),
                data: unusedVar,
                fix: getFix({unusedVar, context})
              }));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
    }
  };

}).call(this);
