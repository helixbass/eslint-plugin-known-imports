// Generated by CoffeeScript 2.5.1
(function() {
  var ExportMap, NON_ROOT_DIRECTORY_IGNORE_PATTERN_REGEX, addDefaultBlacklist, appendToCacheKey, configFileBasenames, createDirectoryCache, defaultBlacklist, directoryCaches, ensureArray, ensureLeadingDot, ffilter, findKnownImport, findKnownImportInDirectory, first, fmapValues, fs, getAddImportFix, getExportMap, getExtensions, getIsNonRootDirectoryPattern, getRemoveImportFix, isArray, isFresh, isString, knownImportExists, knownImportsCache, last, loadConfigFile, loadKnownImports, mergeKnownImportsField, mergeWith, normalizeKnownImportValue, normalizeKnownImports, normalizePath, pathModule, picomatch, pkgDir, shouldIncludeBlankLineBeforeLocalImports, sortBy, startsWith, takeWhile, updateDirectoryCache,
    indexOf = [].indexOf;

  fs = require('fs');

  pathModule = require('path');

  picomatch = require('picomatch');

  ({last, isString, mergeWith, startsWith, first, isArray} = require('lodash'));

  ({
    filter: ffilter,
    mapValues: fmapValues,
    sortBy,
    takeWhile
  } = require('lodash/fp'));

  ({
    default: ExportMap
  } = require('eslint-plugin-import/lib/ExportMap'));

  pkgDir = require('pkg-dir');

  normalizeKnownImports = function(knownImports = {}) {
    if (knownImports.imports) {
      return knownImports;
    }
    return {
      imports: knownImports
    };
  };

  // allKnownImportsKeys = ['imports']
  normalizeKnownImportValue = function(value) {
    if (isString(value)) {
      return {
        module: value
      };
    }
    return value;
  };

  mergeKnownImportsField = function(objValue, srcValue, key) {
    var normalizeKnownImportValues;
    normalizeKnownImportValues = fmapValues(normalizeKnownImportValue);
    if (key === 'imports') {
      return {...normalizeKnownImportValues(objValue != null ? objValue : {}), ...normalizeKnownImportValues(srcValue != null ? srcValue : {})};
    }
  };

  loadConfigFile = function(filename) {
    var file;
    file = fs.readFileSync(filename);
    if (/\.json$/.test(filename)) {
      return JSON.parse(file);
    }
    return require('js-yaml').safeLoad(file);
  };

  configFileBasenames = ['known-imports.yaml', 'known-imports.yml', 'known-imports.json', '.known-imports.yaml', '.known-imports.yml', '.known-imports.json'];

  knownImportsCache = null;

  loadKnownImports = function({settings = {}} = {}) {
    var configFilePath, fromConfig, fromFile, loadedFromFile;
    configFilePath = settings['known-imports/config-file-path'];
    fromFile = ((knownImportsCache != null ? knownImportsCache.configFilePath : void 0) === configFilePath && isFresh({
      cache: knownImportsCache,
      settings
    })) ? knownImportsCache.value : (loadedFromFile = normalizeKnownImports((function() {
      var filename, i, j, len, len1, projectRootDir;
      if (configFilePath) {
        if (!fs.existsSync(configFilePath)) {
          throw new Error(`Couldn't load known imports file '${configFilePath}'`);
        }
        return loadConfigFile(configFilePath);
      }
      for (i = 0, len = configFileBasenames.length; i < len; i++) {
        filename = configFileBasenames[i];
        if (fs.existsSync(filename)) {
          return loadConfigFile(filename);
        }
      }
      projectRootDir = pkgDir.sync();
      if (projectRootDir != null) {
        for (j = 0, len1 = configFileBasenames.length; j < len1; j++) {
          filename = configFileBasenames[j];
          if (fs.existsSync(pathModule.join(projectRootDir, filename))) {
            return loadConfigFile(pathModule.join(projectRootDir, filename));
          }
        }
      }
      return {};
    })()), knownImportsCache = {
      configFilePath,
      lastSeen: process.hrtime(),
      value: loadedFromFile
    }, loadedFromFile);
    fromConfig = settings['known-imports/imports'];
    fromConfig = normalizeKnownImports(fromConfig);
    return mergeWith({}, fromFile, fromConfig, mergeKnownImportsField);
  };

  defaultBlacklist = ['index'];

  addDefaultBlacklist = function(knownImports) {
    if (knownImports == null) {
      return knownImports;
    }
    if (knownImports.blacklist == null) {
      knownImports.blacklist = [];
    }
    knownImports.blacklist = [...knownImports.blacklist, ...defaultBlacklist];
    return knownImports;
  };

  knownImportExists = function({
      name,
      context: {settings},
      context
    }) {
    var blacklist, imports, knownImport, knownImports, whitelist;
    knownImports = addDefaultBlacklist(loadKnownImports({settings}));
    if (knownImports == null) {
      return null;
    }
    ({imports, whitelist, blacklist} = knownImports);
    if ((blacklist != null ? blacklist.length : void 0) && indexOf.call(blacklist, name) >= 0) {
      return null;
    }
    knownImport = imports[name];
    if (knownImport == null) {
      knownImport = findKnownImport({name, whitelist, settings, context});
    }
    return knownImport != null ? knownImport : null;
  };

  isFresh = function({cache, settings}) {
    var lastSeen, lifetime, ref;
    if (cache == null) {
      return;
    }
    ({lastSeen} = cache);
    ({lifetime} = {
      lifetime: 30,
      ...((ref = settings != null ? settings['known-imports/cache'] : void 0) != null ? ref : {})
    });
    return process.hrtime(lastSeen)[0] < lifetime;
  };

  getExportMap = function({
      path,
      context: {settings, parserPath, parserOptions}
    }) {
    return ExportMap.for({path, settings, parserPath, parserOptions});
  };

  appendToCacheKey = function(cache, key, value) {
    var currentValue, ref;
    currentValue = (ref = cache.get(key)) != null ? ref : [];
    return cache.set(key, [...currentValue, value]);
  };

  ensureArray = function(val) {
    if (isArray(val)) {
      return val;
    }
    return [val];
  };

  NON_ROOT_DIRECTORY_IGNORE_PATTERN_REGEX = /^[^\/][^.]*$/;

  getIsNonRootDirectoryPattern = function(ignorePattern) {
    return NON_ROOT_DIRECTORY_IGNORE_PATTERN_REGEX.test(ignorePattern);
  };

  createDirectoryCache = function({
      directory,
      recursive,
      extensions,
      allowed,
      context,
      context: {settings},
      ignore
    }) {
    var cache, getIgnoreMatcher, ignoreMatcher, ignoreMatcherContains, ignoreMatcherNoBasename, scanDir;
    cache = new Map();
    getIgnoreMatcher = function({shouldOnlyMatchNonRootDirectoryPatterns = false, basename = false} = {}) {
      if (ignore == null) {
        return function() {
          return false;
        };
      }
      return picomatch(shouldOnlyMatchNonRootDirectoryPatterns ? ensureArray(ignore).filter(getIsNonRootDirectoryPattern).map(function(ignorePattern) {
        return ignorePattern.replace(/\/$/, '');
      }) : ensureArray(ignore).map(function(ignorePattern) {
        return ignorePattern.replace(/^\//, '').replace(/\/$/, '');
      }), {
        contains: shouldOnlyMatchNonRootDirectoryPatterns,
        cwd: directory,
        basename
      });
    };
    ignoreMatcher = getIgnoreMatcher({
      basename: true
    });
    ignoreMatcherNoBasename = getIgnoreMatcher();
    ignoreMatcherContains = getIgnoreMatcher({
      shouldOnlyMatchNonRootDirectoryPatterns: true
    });
    scanDir = function(dir) {
      var dirName, exports, ext, file, fullPath, i, len, name, namedExport, prefixRelativePath, ref, relativePathWithExtension, results;
      dir = normalizePath(dir);
      ref = fs.readdirSync(dir);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        fullPath = dir + file;
        relativePathWithExtension = fullPath.replace(RegExp(`^${directory}/?`), '');
        if (fs.statSync(fullPath).isDirectory()) {
          if (ignoreMatcherNoBasename(relativePathWithExtension)) {
            continue;
          }
          if (ignoreMatcherContains(relativePathWithExtension)) {
            continue;
          }
          if (recursive) {
            results.push(scanDir(fullPath));
          } else {
            results.push(void 0);
          }
        } else {
          if (ignoreMatcher(relativePathWithExtension)) {
            continue;
          }
          ({
            dir: dirName,
            name,
            ext
          } = pathModule.parse(relativePathWithExtension));
          prefixRelativePath = `${normalizePath(dirName)}${name}`;
          if (indexOf.call(allowed, 'filename') >= 0) {
            if (indexOf.call(extensions, ext) < 0) {
              continue;
            }
            appendToCacheKey(cache, settings['known-imports/case-insensitive-whitelist-filename'] ? name.toLowerCase() : name, {
              prefixRelativePath,
              fullPath,
              type: 'filename'
            });
          }
          if (indexOf.call(allowed, 'named') >= 0) {
            exports = getExportMap({
              path: fullPath,
              context
            });
            if (exports != null) {
              results.push((function() {
                var ref1, results1;
                ref1 = exports.namespace.keys();
                results1 = [];
                for (namedExport of ref1) {
                  if (namedExport !== 'default') {
                    results1.push(appendToCacheKey(cache, namedExport, {
                      prefixRelativePath,
                      fullPath,
                      type: 'named'
                    }));
                  }
                }
                return results1;
              })());
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    };
    scanDir(directory);
    return {
      value: cache,
      lastSeen: process.hrtime()
    };
  };

  directoryCaches = {};

  updateDirectoryCache = function({directory, recursive, extensions, settings, allowed, context, ignore}) {
    var directoryCache;
    directoryCache = directoryCaches[directory];
    if (!isFresh({
      cache: directoryCache,
      settings
    })) {
      directoryCache = directoryCaches[directory] = createDirectoryCache({directory, recursive, extensions, allowed, context, ignore});
    }
    return directoryCache.value;
  };

  normalizePath = function(path) {
    if (!path) {
      return path;
    }
    if (/\/$/.test(path)) {
      return path;
    }
    return `${path}/`;
  };

  getExtensions = function({settings}) {
    var ref;
    return (ref = settings['known-imports/extensions']) != null ? ref : ['.js', '.jsx', '.coffee', '.ts', '.tsx'];
  };

  ensureLeadingDot = function(path) {
    if (path.length && !startsWith(path, '.')) {
      return `./${path}`;
    }
    return path;
  };

  findKnownImportInDirectory = function({directory, allowed = ['filename'], prefix = '', recursive = true, extensions, name, settings, context, projectRootDir, ignore}) {
    var ambiguousMatches, closestFirst, directoryCache, extension, filename, found, foundCaseInsensitive, foundExact, getDotsPrefixLength, getRelativePath, hasAmbiguousMatches, haveSameSharedParentDirectory, importPath, prefixRelativePath, ref, ref1, relativePath, shortestDotsPrefixLength, type;
    if (projectRootDir != null) {
      directory = pathModule.join(projectRootDir, directory);
    }
    directory = normalizePath(directory);
    prefix = normalizePath(prefix);
    directoryCache = updateDirectoryCache({directory, recursive, extensions, settings, allowed, context, ignore});
    foundExact = (ref = directoryCache.get(name)) != null ? ref : [];
    foundCaseInsensitive = (settings['known-imports/case-insensitive-whitelist-filename'] ? (ref1 = directoryCache.get(name.toLowerCase())) != null ? ref1 : [] : []).filter(function({type}) {
      return type === 'filename';
    });
    hasAmbiguousMatches = foundExact.length > 1 || (!foundExact.length && foundCaseInsensitive.length > 1);
    if (settings['known-imports/should-autoimport-ambiguous-imports'] === false && hasAmbiguousMatches) {
      return null;
    }
    filename = context.getFilename();
    getRelativePath = function({fullPath}) {
      return pathModule.relative(pathModule.dirname(filename), fullPath);
    };
    getDotsPrefixLength = function(match) {
      var _, dotsPrefix;
      [_, dotsPrefix] = /^((?:\.\.\/)*)/.exec(getRelativePath(match)); // eslint-disable-line coffee/no-unused-vars
      return dotsPrefix.length;
    };
    found = hasAmbiguousMatches ? (ambiguousMatches = foundExact.length ? foundExact : foundCaseInsensitive, closestFirst = sortBy(getDotsPrefixLength)(ambiguousMatches), shortestDotsPrefixLength = getDotsPrefixLength(closestFirst[0]), haveSameSharedParentDirectory = takeWhile(function(match) {
      return getDotsPrefixLength(match) === shortestDotsPrefixLength;
    })(closestFirst), first(sortBy(function(match) {
      return getRelativePath(match).replace(/\/[^\/]+$/, '').length;
    })(haveSameSharedParentDirectory))) : [...foundExact, ...foundCaseInsensitive][0];
    if (!found) {
      return null;
    }
    ({prefixRelativePath, type} = found);
    importPath = settings['known-imports/relative-paths'] ? (relativePath = getRelativePath(found), extension = pathModule.extname(relativePath), ensureLeadingDot(indexOf.call(extensions, extension) >= 0 ? pathModule.join(pathModule.dirname(relativePath), pathModule.basename(relativePath, extension)) : relativePath)) : `${prefix}${prefixRelativePath}`;
    return {
      module: importPath,
      default: type === 'filename',
      local: true
    };
  };

  findKnownImport = function({name, whitelist, settings = {}, context}) {
    var directoryConfig, extensions, found, i, len, projectRootDir;
    if (!(whitelist != null ? whitelist.length : void 0)) {
      return null;
    }
    extensions = getExtensions({settings});
    projectRootDir = pkgDir.sync();
    for (i = 0, len = whitelist.length; i < len; i++) {
      directoryConfig = whitelist[i];
      if (!(found = findKnownImportInDirectory({...directoryConfig, name, extensions, settings, context, projectRootDir}))) {
        continue;
      }
      return found;
    }
  };

  shouldIncludeBlankLineBeforeLocalImports = function({
      context: {settings = {}}
    }) {
    return !!settings['known-imports/blank-line-before-local-imports'];
  };

  getAddImportFix = function({name, context, allImports, lastNonlocalImport}) {
    var importName, knownImport, sourceCode;
    knownImport = knownImportExists({name, context});
    if (knownImport == null) {
      return null;
    }
    sourceCode = context.getSourceCode();
    importName = `${knownImport.namespace ? '* as ' : knownImport.name ? `${knownImport.name} as ` : ''}${name}`;
    return function(fixer) {
      var appendOnlyNamedImport, appendToExistingNamedImports, existingImport, insertNewImport, lastExistingImport, lastSpecifier, namedImports, prependDefaultImport;
      prependDefaultImport = function() {
        var leadingBrace;
        // TODO: check that there's not already a default import?
        leadingBrace = sourceCode.getTokenBefore(existingImport.specifiers[0]);
        return fixer.insertTextBefore(leadingBrace, `${importName}, `);
      };
      appendToExistingNamedImports = function() {
        return fixer.insertTextAfter(last(namedImports), `, ${importName}`);
      };
      appendOnlyNamedImport = function() {
        return fixer.insertTextAfter(lastSpecifier, `, {${importName}}`);
      };
      existingImport = allImports.find(function({source}) {
        return source.value === knownImport.module;
      });
      if (existingImport) {
        if (knownImport.default) {
          return prependDefaultImport();
        }
        namedImports = ffilter({
          type: 'ImportSpecifier'
        })(existingImport.specifiers);
        if (namedImports.length) {
          return appendToExistingNamedImports();
        }
        lastSpecifier = last(existingImport.specifiers);
        return appendOnlyNamedImport();
      }
      lastExistingImport = (function() {
        if (!allImports.length) {
          return null;
        }
        if (lastNonlocalImport.found == null) {
          lastNonlocalImport.found = allImports.find(function({range}) {
            var followingChars;
            followingChars = sourceCode.text.slice(range[1], (range[1] + 2));
            return followingChars === '\n\n';
          });
        }
        if (knownImport.local) {
          return last(allImports);
        }
        if (lastNonlocalImport.found != null) {
          return lastNonlocalImport.found;
        }
        return last(allImports);
      })();
      insertNewImport = function(text) {
        var firstProgramToken, onlyExistingNonlocalImports;
        if (lastExistingImport) {
          return fixer.insertTextAfter(lastExistingImport, `\n${(knownImport.local && shouldIncludeBlankLineBeforeLocalImports({context})) ? (onlyExistingNonlocalImports = lastNonlocalImport.found === last(allImports), onlyExistingNonlocalImports ? '\n' : '') : ''}${text}`);
        }
        firstProgramToken = sourceCode.getFirstToken(sourceCode.ast, {
          // skip directives
          filter: function({type}) {
            return type !== 'String';
          }
        });
        return fixer.insertTextBefore(firstProgramToken, `${text}\n\n`);
      };
      return insertNewImport(`import ${knownImport.default || knownImport.namespace ? importName : `{${importName}}`} from '${knownImport.module}'`);
    };
  };

  getRemoveImportFix = function({unusedVar, onlyRemoveKnownImports, context}) {
    var def, importDeclaration, importSpecifier, sourceCode;
    def = unusedVar.defs[0];
    if (def.type !== 'ImportBinding') {
      return null;
    }
    if (onlyRemoveKnownImports && !knownImportExists({
      name: unusedVar.name,
      context
    })) {
      return null;
    }
    importDeclaration = def.parent;
    importSpecifier = def.node;
    sourceCode = context.getSourceCode();
    return function(fixer) {
      var isOnlyNamedImport, nextToken, precedingToken, removeBracesAndPrecedingComma, removeEntireImport, removeThroughFollowingComma, removeThroughPrecedingComma;
      removeEntireImport = function() {
        var importIsAtBeginningOfFile, nextToken, nextTokenIsPrecededByBlankLine, precedingComments;
        nextToken = sourceCode.getTokenAfter(importDeclaration);
        if ((precedingComments = sourceCode.getCommentsBefore(nextToken)).length) {
          nextToken = precedingComments[0];
        }
        nextTokenIsPrecededByBlankLine = sourceCode.text.slice((nextToken.range[0] - 2), nextToken.range[0]) === '\n\n';
        importIsAtBeginningOfFile = !sourceCode.getTokenBefore(importDeclaration);
        return fixer.removeRange([importDeclaration.range[0], nextTokenIsPrecededByBlankLine && !importIsAtBeginningOfFile ? nextToken.range[0] - 1 : nextToken.range[0]]);
      };
      removeThroughFollowingComma = function({commaToken}) {
        var followingToken;
        followingToken = sourceCode.getTokenAfter(commaToken);
        return fixer.removeRange([importSpecifier.range[0], followingToken.range[0]]);
      };
      removeThroughPrecedingComma = function({commaToken}) {
        var beforeToken;
        beforeToken = sourceCode.getTokenBefore(commaToken);
        return fixer.removeRange([beforeToken.range[1], importSpecifier.range[1]]);
      };
      removeBracesAndPrecedingComma = function() {
        var beforeToken, closingBrace, openingBrace, precedingComma;
        openingBrace = sourceCode.getTokenBefore(importSpecifier, {
          filter: function({value}) {
            return value === '{';
          }
        });
        closingBrace = sourceCode.getTokenAfter(importSpecifier, {
          filter: function({value}) {
            return value === '}';
          }
        });
        precedingComma = sourceCode.getTokenBefore(openingBrace);
        // assert(precedingComma.value === ',')
        beforeToken = sourceCode.getTokenBefore(precedingComma);
        return fixer.removeRange([beforeToken.range[1], closingBrace.range[1]]);
      };
      if (importDeclaration.specifiers.length === 1) {
        // followingComma = sourceCode.getTokenAfter(closingBrace)
        return removeEntireImport();
      }
      nextToken = sourceCode.getTokenAfter(importSpecifier);
      if (nextToken.value === ',') {
        return removeThroughFollowingComma({
          commaToken: nextToken
        });
      }
      precedingToken = sourceCode.getTokenBefore(importSpecifier);
      if (precedingToken.value === ',') {
        return removeThroughPrecedingComma({
          commaToken: precedingToken
        });
      }
      isOnlyNamedImport = importSpecifier.type === 'ImportSpecifier' && importDeclaration.specifiers.filter(function({type}) {
        return type === 'ImportSpecifier';
      }).length === 1;
      if (isOnlyNamedImport) {
        return removeBracesAndPrecedingComma();
      }
      return fixer.remove(importSpecifier);
    };
  };

  module.exports = {knownImportExists, getAddImportFix, getRemoveImportFix};

}).call(this);
