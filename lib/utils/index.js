// Generated by CoffeeScript 2.5.1
(function() {
  var ExportMap, addDefaultBlacklist, configFileBasenames, createDirectoryCache, defaultBlacklist, directoryCaches, ffilter, findKnownImport, findKnownImportInDirectory, fmapValues, fs, getAddImportFix, getExportMap, isFresh, isString, knownImportExists, knownImportsCache, last, loadConfigFile, loadKnownImports, mergeKnownImportsField, mergeWith, normalizeKnownImportValue, normalizeKnownImports, normalizePath, pathModule, pkgDir, shouldIncludeBlankLineBeforeLocalImports, updateDirectoryCache,
    indexOf = [].indexOf;

  fs = require('fs');

  pathModule = require('path');

  ({last, isString, mergeWith} = require('lodash'));

  ({
    filter: ffilter,
    mapValues: fmapValues
  } = require('lodash/fp'));

  ({
    default: ExportMap
  } = require('eslint-plugin-import/lib/ExportMap'));

  pkgDir = require('pkg-dir');

  normalizeKnownImports = function(knownImports = {}) {
    if (knownImports.imports) {
      return knownImports;
    }
    return {
      imports: knownImports
    };
  };

  // allKnownImportsKeys = ['imports']
  normalizeKnownImportValue = function(value) {
    if (isString(value)) {
      return {
        module: value
      };
    }
    return value;
  };

  mergeKnownImportsField = function(objValue, srcValue, key) {
    var normalizeKnownImportValues;
    normalizeKnownImportValues = fmapValues(normalizeKnownImportValue);
    if (key === 'imports') {
      return {...normalizeKnownImportValues(objValue != null ? objValue : {}), ...normalizeKnownImportValues(srcValue != null ? srcValue : {})};
    }
  };

  loadConfigFile = function(filename) {
    var file;
    file = fs.readFileSync(filename);
    if (/\.json$/.test(filename)) {
      return JSON.parse(file);
    }
    return require('js-yaml').safeLoad(file);
  };

  configFileBasenames = ['known-imports.yaml', 'known-imports.yml', 'known-imports.json', '.known-imports.yaml', '.known-imports.yml', '.known-imports.json'];

  knownImportsCache = null;

  loadKnownImports = function({settings = {}} = {}) {
    var configFilePath, fromConfig, fromFile, loadedFromFile;
    configFilePath = settings['known-imports/config-file-path'];
    fromFile = ((knownImportsCache != null ? knownImportsCache.configFilePath : void 0) === configFilePath && isFresh({
      cache: knownImportsCache,
      settings
    })) ? knownImportsCache.value : (loadedFromFile = normalizeKnownImports((function() {
      var filename, i, j, len, len1, projectRootDir;
      if (configFilePath) {
        if (!fs.existsSync(configFilePath)) {
          throw new Error(`Couldn't load known imports file '${configFilePath}'`);
        }
        return loadConfigFile(configFilePath);
      }
      for (i = 0, len = configFileBasenames.length; i < len; i++) {
        filename = configFileBasenames[i];
        if (fs.existsSync(filename)) {
          return loadConfigFile(filename);
        }
      }
      projectRootDir = pkgDir.sync();
      if (projectRootDir != null) {
        for (j = 0, len1 = configFileBasenames.length; j < len1; j++) {
          filename = configFileBasenames[j];
          if (fs.existsSync(pathModule.join(projectRootDir, filename))) {
            return loadConfigFile(pathModule.join(projectRootDir, filename));
          }
        }
      }
      return {};
    })()), knownImportsCache = {
      configFilePath,
      lastSeen: process.hrtime(),
      value: loadedFromFile
    }, loadedFromFile);
    fromConfig = settings['known-imports/imports'];
    fromConfig = normalizeKnownImports(fromConfig);
    return mergeWith({}, fromFile, fromConfig, mergeKnownImportsField);
  };

  defaultBlacklist = ['index'];

  addDefaultBlacklist = function(knownImports) {
    if (knownImports == null) {
      return knownImports;
    }
    if (knownImports.blacklist == null) {
      knownImports.blacklist = [];
    }
    knownImports.blacklist = [...knownImports.blacklist, ...defaultBlacklist];
    return knownImports;
  };

  knownImportExists = function({
      name,
      context: {settings},
      context
    }) {
    var blacklist, imports, knownImport, knownImports, whitelist;
    knownImports = addDefaultBlacklist(loadKnownImports({settings}));
    if (knownImports == null) {
      return null;
    }
    ({imports, whitelist, blacklist} = knownImports);
    if ((blacklist != null ? blacklist.length : void 0) && indexOf.call(blacklist, name) >= 0) {
      return null;
    }
    knownImport = imports[name];
    if (knownImport == null) {
      knownImport = findKnownImport({name, whitelist, settings, context});
    }
    return knownImport != null ? knownImport : null;
  };

  isFresh = function({cache, settings}) {
    var lastSeen, lifetime, ref;
    if (cache == null) {
      return;
    }
    ({lastSeen} = cache);
    ({lifetime} = {
      lifetime: 30,
      ...((ref = settings != null ? settings['known-imports/cache'] : void 0) != null ? ref : {})
    });
    return process.hrtime(lastSeen)[0] < lifetime;
  };

  getExportMap = function({
      path,
      context: {settings, parserPath, parserOptions}
    }) {
    return ExportMap.for({path, settings, parserPath, parserOptions});
  };

  createDirectoryCache = function({directory, recursive, extensions, allowed, context}) {
    var cache, scanDir;
    cache = new Map();
    scanDir = function(dir) {
      var dirName, exports, ext, file, fullPath, i, len, name, namedExport, ref, relativePath, relativePathWithExtension, results;
      dir = normalizePath(dir);
      ref = fs.readdirSync(dir);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        fullPath = dir + file;
        if (fs.statSync(fullPath).isDirectory()) {
          if (recursive) {
            results.push(scanDir(fullPath));
          } else {
            results.push(void 0);
          }
        } else {
          relativePathWithExtension = fullPath.replace(RegExp(`^${directory}/?`), '');
          ({
            dir: dirName,
            name,
            ext
          } = pathModule.parse(relativePathWithExtension));
          relativePath = `${normalizePath(dirName)}${name}`;
          if (indexOf.call(allowed, 'filename') >= 0) {
            if (indexOf.call(extensions, ext) < 0) {
              continue;
            }
            cache.set(name, {
              relativePath,
              type: 'filename'
            });
          }
          if (indexOf.call(allowed, 'named') >= 0) {
            exports = getExportMap({
              path: fullPath,
              context
            });
            if (exports != null) {
              results.push((function() {
                var ref1, results1;
                ref1 = exports.namespace.keys();
                results1 = [];
                for (namedExport of ref1) {
                  if (namedExport !== 'default') {
                    results1.push(cache.set(namedExport, {
                      relativePath,
                      type: 'named'
                    }));
                  }
                }
                return results1;
              })());
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    };
    scanDir(directory);
    return {
      value: cache,
      lastSeen: process.hrtime()
    };
  };

  directoryCaches = {};

  updateDirectoryCache = function({directory, recursive, extensions, settings, allowed, context}) {
    var directoryCache;
    directoryCache = directoryCaches[directory];
    if (!isFresh({
      cache: directoryCache,
      settings
    })) {
      directoryCache = directoryCaches[directory] = createDirectoryCache({directory, recursive, extensions, allowed, context});
    }
    return directoryCache.value;
  };

  normalizePath = function(path) {
    if (!path) {
      return path;
    }
    if (/\/$/.test(path)) {
      return path;
    }
    return `${path}/`;
  };

  findKnownImportInDirectory = function({directory, allowed = ['filename'], prefix = '', recursive = true, extensions, name, settings, context, projectRootDir}) {
    var directoryCache, found, importPath, relativePath, type;
    if (projectRootDir != null) {
      directory = pathModule.join(projectRootDir, directory);
    }
    directory = normalizePath(directory);
    prefix = normalizePath(prefix);
    directoryCache = updateDirectoryCache({directory, recursive, extensions, settings, allowed, context});
    if (!(found = directoryCache.get(name))) {
      return null;
    }
    ({relativePath, type} = found);
    importPath = `${prefix}${relativePath}`;
    return {
      module: importPath,
      default: type === 'filename',
      local: true
    };
  };

  findKnownImport = function({name, whitelist, settings = {}, context}) {
    var directoryConfig, extensions, found, i, len, projectRootDir, ref;
    if (!(whitelist != null ? whitelist.length : void 0)) {
      return null;
    }
    extensions = (ref = settings['known-imports/extensions']) != null ? ref : ['.js', '.jsx', '.coffee'];
    projectRootDir = pkgDir.sync();
    for (i = 0, len = whitelist.length; i < len; i++) {
      directoryConfig = whitelist[i];
      if (!(found = findKnownImportInDirectory({...directoryConfig, name, extensions, settings, context, projectRootDir}))) {
        continue;
      }
      return found;
    }
  };

  shouldIncludeBlankLineBeforeLocalImports = function({
      context: {settings = {}}
    }) {
    return !!settings['known-imports/blank-line-before-local-imports'];
  };

  getAddImportFix = function({name, context, allImports, lastNonlocalImport}) {
    var importName, knownImport, sourceCode;
    knownImport = knownImportExists({name, context});
    if (knownImport == null) {
      return null;
    }
    sourceCode = context.getSourceCode();
    importName = `${knownImport.namespace ? '* as ' : knownImport.name ? `${knownImport.name} as ` : ''}${name}`;
    return function(fixer) {
      var appendOnlyNamedImport, appendToExistingNamedImports, existingImport, insertNewImport, lastExistingImport, lastSpecifier, namedImports, prependDefaultImport;
      prependDefaultImport = function() {
        var leadingBrace;
        // TODO: check that there's not already a default import?
        leadingBrace = sourceCode.getTokenBefore(existingImport.specifiers[0]);
        return fixer.insertTextBefore(leadingBrace, `${importName}, `);
      };
      appendToExistingNamedImports = function() {
        return fixer.insertTextAfter(last(namedImports), `, ${importName}`);
      };
      appendOnlyNamedImport = function() {
        return fixer.insertTextAfter(lastSpecifier, `, {${importName}}`);
      };
      existingImport = allImports.find(function({source}) {
        return source.value === knownImport.module;
      });
      if (existingImport) {
        if (knownImport.default) {
          return prependDefaultImport();
        }
        namedImports = ffilter({
          type: 'ImportSpecifier'
        })(existingImport.specifiers);
        if (namedImports.length) {
          return appendToExistingNamedImports();
        }
        lastSpecifier = last(existingImport.specifiers);
        return appendOnlyNamedImport();
      }
      lastExistingImport = (function() {
        if (!allImports.length) {
          return null;
        }
        if (lastNonlocalImport.found == null) {
          lastNonlocalImport.found = allImports.find(function({range}) {
            var followingChars;
            followingChars = sourceCode.text.slice(range[1], (range[1] + 2));
            return followingChars === '\n\n';
          });
        }
        if (knownImport.local) {
          return last(allImports);
        }
        if (lastNonlocalImport.found != null) {
          return lastNonlocalImport.found;
        }
        return last(allImports);
      })();
      insertNewImport = function(text) {
        var firstProgramToken, onlyExistingNonlocalImports;
        if (lastExistingImport) {
          return fixer.insertTextAfter(lastExistingImport, `\n${(knownImport.local && shouldIncludeBlankLineBeforeLocalImports({context})) ? (onlyExistingNonlocalImports = lastNonlocalImport.found === last(allImports), onlyExistingNonlocalImports ? '\n' : '') : ''}${text}`);
        }
        firstProgramToken = sourceCode.getFirstToken(sourceCode.ast, {
          // skip directives
          filter: function({type}) {
            return type !== 'String';
          }
        });
        return fixer.insertTextBefore(firstProgramToken, `${text}\n\n`);
      };
      return insertNewImport(`import ${knownImport.default || knownImport.namespace ? importName : `{${importName}}`} from '${knownImport.module}'`);
    };
  };

  module.exports = {knownImportExists, getAddImportFix};

}).call(this);
